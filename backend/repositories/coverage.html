
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>repositories: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/A4-dev-team/mobileorder.git/repositories/item_repository.go (83.3%)</option>
				
				<option value="file1">github.com/A4-dev-team/mobileorder.git/repositories/order_repository.go (82.3%)</option>
				
				<option value="file2">github.com/A4-dev-team/mobileorder.git/repositories/shop_repository.go (90.9%)</option>
				
				<option value="file3">github.com/A4-dev-team/mobileorder.git/repositories/user_repository.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package repositories

import (
        "context"
        "errors"

        "github.com/A4-dev-team/mobileorder.git/apperrors"
        "github.com/A4-dev-team/mobileorder.git/models"
        "github.com/jmoiron/sqlx"
)

type ItemRepository interface {
        ValidateAndGetItemsForShop(ctx context.Context, shopID int, itemIDs []int) (map[int]models.Item, error)
        GetItemList(shopID int) ([]models.ItemListResponse, error)
}

type itemRepository struct {
        db DBTX
}

func NewItemRepository(db DBTX) ItemRepository <span class="cov8" title="1">{
        return &amp;itemRepository{db}
}</span>

func (r *itemRepository) ValidateAndGetItemsForShop(ctx context.Context, shopID int, itemIDs []int) (map[int]models.Item, error) <span class="cov8" title="1">{
        //商品IDで商品情報取得
        itemMap := make(map[int]models.Item)

        if len(itemIDs) == 0 </span><span class="cov8" title="1">{
                return itemMap, nil
        }</span>

        <span class="cov8" title="1">const baseQuery = `
                SELECT
                        i.item_id,
                        i.item_name,
                        i.price,
                        i.is_available
                FROM
                        items i
                INNER JOIN
                        shop_item si ON i.item_id = si.item_id
                WHERE
                        si.shop_id = ? AND i.item_id IN (?)
        `

        query, args, err := sqlx.In(baseQuery, shopID, itemIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.GetDataFailed.Wrap(err, "データベースクエリの構築に失敗しました。")
        }</span>
        <span class="cov8" title="1">query = r.db.Rebind(query)

        var items []models.Item
        if err := r.db.SelectContext(ctx, &amp;items, query, args...); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.GetDataFailed.Wrap(err, "店舗の所属商品情報の取得に失敗しました。")
        }</span>

        <span class="cov8" title="1">if len(items) != len(itemIDs) </span><span class="cov8" title="1">{
                return nil, apperrors.BadParam.Wrap(errors.New("invalid item id requested"), "リクエストに、存在しないか店舗に属さない商品が含まれています。")
        }</span>

        <span class="cov8" title="1">for _, i := range items </span><span class="cov8" title="1">{
                itemMap[i.ItemID] = i
        }</span>

        <span class="cov8" title="1">return itemMap, nil</span>

}

func (r *itemRepository) GetItemList(shopID int) ([]models.ItemListResponse, error) <span class="cov0" title="0">{
        //TODO
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "errors"
        "time"

        "github.com/A4-dev-team/mobileorder.git/apperrors"
        "github.com/A4-dev-team/mobileorder.git/models"
        "github.com/jmoiron/sqlx"
)

type OrderRepository interface {
        CreateOrder(ctx context.Context, order *models.Order, items []models.OrderItem) error
        UpdateUserIDByGuestToken(ctx context.Context, guestToken string, userID int) error
        FindActiveUserOrders(ctx context.Context, userID int) ([]OrderWithDetailsDB, error)
        FindItemsByOrderIDs(ctx context.Context, orderIDs []int) (map[int][]models.ItemDetail, error)
        FindOrderByIDAndUser(ctx context.Context, orderID int, userID int) (*models.Order, error)
        CountWaitingOrders(ctx context.Context, shopID int, orderDate time.Time) (int, error)
        FindShopOrdersByStatuses(ctx context.Context, shopID int, statuses []models.OrderStatus) ([]AdminOrderDBResult, error)
        FindOrderByIDAndShopID(ctx context.Context, orderID int, shopID int) (*models.Order, error)
        UpdateOrderStatus(ctx context.Context, orderID int, shopID int, newStatus models.OrderStatus) error
        DeleteOrderByIDAndShopID(ctx context.Context, orderID int, shopID int) error
}

type orderRepository struct {
        db DBTX
}

func NewOrderRepository(db DBTX) OrderRepository <span class="cov8" title="1">{
        return &amp;orderRepository{db}
}</span>

func (r *orderRepository) CreateOrder(ctx context.Context, order *models.Order, items []models.OrderItem) error <span class="cov8" title="1">{
        orderQuery := `
                INSERT INTO orders (user_id, shop_id, order_date, total_amount, guest_order_token, status)
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING order_id, created_at, updated_at
        `
        err := r.db.QueryRowxContext(
                ctx,
                orderQuery,
                order.UserID,
                order.ShopID,
                time.Now(),
                order.TotalAmount,
                order.GuestOrderToken,
                order.Status,
        ).Scan(&amp;order.OrderID, &amp;order.CreatedAt, &amp;order.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return apperrors.InsertDataFailed.Wrap(err, "注文の作成に失敗しました。")
        }</span>

        <span class="cov8" title="1">stmt, err := r.db.PreparexContext(ctx, "INSERT INTO order_item (order_id, item_id, quantity, price_at_order) VALUES ($1, $2, $3, $4)")
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.InsertDataFailed.Wrap(err, "注文商品登録の準備に失敗しました。")
        }</span>
        <span class="cov8" title="1">defer stmt.Close()

        for _, item := range items </span><span class="cov8" title="1">{
                if _, err = stmt.ExecContext(ctx, order.OrderID, item.ItemID, item.Quantity, item.PriceAtOrder); err != nil </span><span class="cov8" title="1">{
                        return apperrors.InsertDataFailed.Wrap(err, "注文商品の登録に失敗しました。")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *orderRepository) UpdateUserIDByGuestToken(ctx context.Context, guestToken string, userID int) error <span class="cov8" title="1">{
        query := "UPDATE orders SET user_id = $1 WHERE guest_order_token = $2"
        result, err := r.db.ExecContext(ctx, query, userID, guestToken)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.UpdateDataFailed.Wrap(err, "ゲスト注文のユーザー紐付けに失敗しました。")
        }</span>
        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.UpdateDataFailed.Wrap(err, "更新結果の取得に失敗しました。")
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return apperrors.NoData.Wrap(nil, "指定されたゲスト注文は見つかりませんでした。")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ユーザーの注文情報をとってくる。
type OrderWithDetailsDB struct {
        OrderID      int                `db:"order_id"`
        ShopName     string             `db:"shop_name"`
        Location     string             `db:"location"`
        OrderDate    time.Time          `db:"order_date"`
        TotalAmount  float64            `db:"total_amount"`
        Status       models.OrderStatus `db:"status"`
        WaitingCount int                `db:"waiting_count"`
}

func (r *orderRepository) FindActiveUserOrders(ctx context.Context, userID int) ([]OrderWithDetailsDB, error) <span class="cov8" title="1">{
        query := `
                SELECT
                        o.order_id,
                        s.name AS shop_name,
                        s.location,
                        o.order_date,
                        o.total_amount,
                        o.status,
                        CASE
                                WHEN o.status = $1 THEN
                                        (SELECT COUNT(*)
                                         FROM orders sub
                                         WHERE sub.shop_id = o.shop_id AND sub.status = $1 AND sub.order_date &lt; o.order_date)
                                ELSE 0
                        END AS waiting_count
                FROM
                        orders o
                INNER JOIN
                        shops s ON o.shop_id = s.shop_id
                WHERE
                        o.status IN ($1, $2) AND o.user_id = $3
                ORDER BY
                        o.order_date DESC;
        `

        var orders []OrderWithDetailsDB
        if err := r.db.SelectContext(ctx, &amp;orders, query, models.Cooking, models.Completed, userID); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.GetDataFailed.Wrap(err, "アクティブな注文履歴の取得に失敗しました。")
        }</span>

        <span class="cov8" title="1">return orders, nil</span>
}

// 注文IDに対応する商品をとってくる
func (r *orderRepository) FindItemsByOrderIDs(ctx context.Context, orderIDs []int) (map[int][]models.ItemDetail, error) <span class="cov8" title="1">{
        if len(orderIDs) == 0 </span><span class="cov8" title="1">{
                return make(map[int][]models.ItemDetail), nil
        }</span>

        <span class="cov8" title="1">query, args, err := sqlx.In(`
                SELECT oi.order_id, i.item_name, oi.quantity
                FROM order_item oi
                INNER JOIN items i ON oi.item_id = i.item_id
                WHERE oi.order_id IN (?)
        `, orderIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">query = r.db.Rebind(query)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.GetDataFailed.Wrap(err, "データベースクエリの実行に失敗しました。")
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        itemsMap := make(map[int][]models.ItemDetail)
        for rows.Next() </span><span class="cov8" title="1">{
                var orderID int
                var item models.ItemDetail
                if err := rows.Scan(&amp;orderID, &amp;item.ItemName, &amp;item.Quantity); err != nil </span><span class="cov0" title="0">{
                        return nil, apperrors.GetDataFailed.Wrap(err, "注文商品データの読み取りに失敗しました。")
                }</span>
                <span class="cov8" title="1">itemsMap[orderID] = append(itemsMap[orderID], item)</span>
        }

        <span class="cov8" title="1">return itemsMap, nil</span>
}

func (r *orderRepository) FindOrderByIDAndUser(ctx context.Context, orderID int, userID int) (*models.Order, error) <span class="cov8" title="1">{
        var order models.Order
        query := "SELECT * FROM orders WHERE order_id = $1 AND user_id = $2"
        if err := r.db.GetContext(ctx, &amp;order, query, orderID, userID); err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, apperrors.NoData.Wrap(err, "注文が見つからないか、アクセス権がありません。")
                }</span>
                <span class="cov0" title="0">return nil, apperrors.GetDataFailed.Wrap(err, "注文情報の取得に失敗しました。")</span>
        }
        <span class="cov8" title="1">return &amp;order, nil</span>
}

func (r *orderRepository) CountWaitingOrders(ctx context.Context, shopID int, orderDate time.Time) (int, error) <span class="cov8" title="1">{
        var count int
        query := `SELECT COUNT(*) FROM orders WHERE shop_id = $1 AND status = $2 AND order_date &lt; $3`
        if err := r.db.GetContext(ctx, &amp;count, query, shopID, models.Cooking, orderDate); err != nil </span><span class="cov0" title="0">{
                return 0, apperrors.GetDataFailed.Wrap(err, "待ち人数の取得に失敗しました。")
        }</span>
        <span class="cov8" title="1">return count, nil</span>
}

// 管理者が注文取得
type AdminOrderDBResult struct {
        OrderID       int                `db:"order_id"`
        CustomerEmail sql.NullString     `db:"email"`
        OrderDate     time.Time          `db:"order_date"`
        TotalAmount   float64            `db:"total_amount"`
        Status        models.OrderStatus `db:"status"`
}

func (r *orderRepository) FindShopOrdersByStatuses(ctx context.Context, shopID int, statuses []models.OrderStatus) ([]AdminOrderDBResult, error) <span class="cov8" title="1">{
        if len(statuses) == 0 </span><span class="cov8" title="1">{
                return []AdminOrderDBResult{}, nil
        }</span>
        <span class="cov8" title="1">query, args, err := sqlx.In(`
                SELECT
                        o.order_id, u.email, o.order_date, o.total_amount, o.status
                FROM
                        orders o
                LEFT JOIN
                        users u ON o.user_id = u.user_id
                WHERE
                        o.shop_id = ? AND o.status IN (?)
                ORDER BY
                        o.order_date ASC
        `, shopID, statuses)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.GetDataFailed.Wrap(err, "データベースクエリの構築に失敗しました。")
        }</span>
        <span class="cov8" title="1">query = r.db.Rebind(query)

        var orders []AdminOrderDBResult
        if err := r.db.SelectContext(ctx, &amp;orders, query, args...); err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.GetDataFailed.Wrap(err, "店舗の注文情報取得に失敗しました。")
        }</span>
        <span class="cov8" title="1">return orders, nil</span>
}

func (r *orderRepository) FindOrderByIDAndShopID(ctx context.Context, orderID int, shopID int) (*models.Order, error) <span class="cov8" title="1">{
        var order models.Order
        query := `SELECT * FROM orders WHERE order_id = $1 AND shop_id = $2`
        err := r.db.GetContext(ctx, &amp;order, query, orderID, shopID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, apperrors.NoData.Wrap(err, "注文が見つからないか、この店舗の管轄外です。")
                }</span>
                <span class="cov0" title="0">return nil, apperrors.GetDataFailed.Wrap(err, "注文情報の取得に失敗しました。")</span>
        }

        <span class="cov8" title="1">return &amp;order, nil</span>
}

func (r *orderRepository) UpdateOrderStatus(ctx context.Context, orderID int, shopID int, newStatus models.OrderStatus) error <span class="cov8" title="1">{
        query := `UPDATE orders SET status = $1, updated_at = NOW() WHERE order_id = $2 AND shop_id = $3`
        result, err := r.db.ExecContext(ctx, query, newStatus, orderID, shopID)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.UpdateDataFailed.Wrap(err, "注文ステータスの更新に失敗しました。")
        }</span>
        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.UpdateDataFailed.Wrap(err, "更新結果の取得に失敗しました。")
        }</span>
        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return apperrors.NoData.Wrap(nil, "更新対象の注文が見つからないか、管轄外です。")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *orderRepository) DeleteOrderByIDAndShopID(ctx context.Context, orderID int, shopID int) error <span class="cov8" title="1">{
        query := `DELETE FROM orders WHERE order_id = $1 AND shop_id = $2`
        result, err := r.db.ExecContext(ctx, query, orderID, shopID)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.DeleteDataFailed.Wrap(err, "注文の削除に失敗しました。")
        }</span>

        <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.DeleteDataFailed.Wrap(err, "削除結果の取得に失敗しました。")
        }</span>

        <span class="cov8" title="1">if rowsAffected == 0 </span><span class="cov8" title="1">{
                return apperrors.NoData.Wrap(nil, "削除対象の注文が見つからないか、管轄外です。")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

</pre>
		
		<pre class="file" id="file2" style="display: none">package repositories

import (
        "context"
        "fmt"

        "github.com/A4-dev-team/mobileorder.git/apperrors"
)

type ShopRepository interface {
        FindShopIDByAdminID(ctx context.Context, userID int) (int, error)
}

type shopRepository struct {
        db DBTX
}

func NewShopRepository(db DBTX) ShopRepository <span class="cov8" title="1">{
        return &amp;shopRepository{db}
}</span>

func (r *shopRepository) FindShopIDByAdminID(ctx context.Context, userID int) (int, error) <span class="cov8" title="1">{
        var shopIDs []int
        query := `
                SELECT s.shop_id FROM shops s
                INNER JOIN shop_staff ss ON s.shop_id = ss.shop_id
                WHERE ss.user_id = $1
        `
        err := r.db.SelectContext(ctx, &amp;shopIDs, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, apperrors.GetDataFailed.Wrap(err, "管理者所属店舗の取得に失敗しました。")
        }</span>

        <span class="cov8" title="1">switch len(shopIDs) </span>{
        case 0:<span class="cov8" title="1">
                return 0, apperrors.NoData.Wrap(nil, "この管理者アカウントに紐づく店舗が見つかりません。")</span>
        case 1:<span class="cov8" title="1">
                return shopIDs[0], nil</span>
        default:<span class="cov8" title="1">
                err := fmt.Errorf("data inconsistency: user_id %d is associated with multiple shops", userID)
                return 0, apperrors.Unknown.Wrap(err, "データ不整合が発生しました。")</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "errors"

        "github.com/A4-dev-team/mobileorder.git/apperrors"
        "github.com/A4-dev-team/mobileorder.git/models"
        "github.com/lib/pq"
)

type UserRepository interface {
        CreateUser(ctx context.Context, user *models.User) error
        GetUserByEmail(ctx context.Context, email string) (models.User, error)
}

type userRepository struct {
        db DBTX
}

func NewUserRepository(db DBTX) UserRepository <span class="cov8" title="1">{
        return &amp;userRepository{db}
}</span>

func (r *userRepository) CreateUser(ctx context.Context, user *models.User) error <span class="cov8" title="1">{
        // 新規ユーザーのデフォルトロールは'customer'に設定
        user.Role = models.CustomerRole
        query := `INSERT INTO users (email, role) VALUES ($1, $2) RETURNING user_id, created_at, updated_at`
        err := r.db.QueryRowxContext(ctx, query, user.Email, user.Role).Scan(
                &amp;user.UserID,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov8" title="1">{
                if pgErr, ok := err.(*pq.Error); ok &amp;&amp; pgErr.Code == "23505" </span><span class="cov8" title="1">{
                        return apperrors.Conflict.Wrap(err, "このメールアドレスは既に使用されています。")
                }</span>
                <span class="cov0" title="0">return apperrors.InsertDataFailed.Wrap(err, "ユーザーの作成に失敗しました。")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *userRepository) GetUserByEmail(ctx context.Context, email string) (models.User, error) <span class="cov8" title="1">{
        user := models.User{}
        query := "SELECT user_id, email, role, created_at, updated_at FROM users WHERE email = $1"
        if err := r.db.GetContext(ctx, &amp;user, query, email); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return models.User{}, apperrors.NoData.Wrap(err, "指定されたメールアドレスのユーザーは見つかりませんでした。")
                }</span>
                <span class="cov0" title="0">return models.User{}, apperrors.GetDataFailed.Wrap(err, "ユーザー情報の取得に失敗しました。")</span>
        }
        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
